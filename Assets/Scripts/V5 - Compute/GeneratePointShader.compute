// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "NoiseShader.compute"
#include "Includes/NoiseShader.compute"
#include "Includes/PositionShader.compute"





//Noise variables
//float noiseScale;
//float surfaceLevel;

StructuredBuffer<float3> offsets;
int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float floorOffset;
float weightMultiplier;
bool closeEdges;
float hardFloor;
float hardFloorWeight;
float4 params;
float radius;

float Unity_InverseLerp_float4(float4 A, float4 B, float4 T)
{
    return (T - A)/(B - A);
}

[numthreads(numThreads,numThreads,numThreads)]
void CSMain (uint3 id : SV_DispatchThreadID)
{



    if (id.x >= numOfPointsPerAxis || id.y >= numOfPointsPerAxis || id.z >= numOfPointsPerAxis) {
        return;
    }
    float3 pos = centre + id * spacing - (chunkSize * 0.5f);

    //Nabbed from https://github.com/SebLague/Marching-Cubes/blob/master/Assets/Scripts/Compute/NoiseDensity.compute for noise
    float offsetNoise = 0;

    float noise = 0;

    float frequency = noiseScale/100;
    float amplitude = 1;
    float weight = 1;
    for (int j =0; j < octaves; j ++) {
        float n = snoise((pos+offsetNoise) * frequency + offsets[j] + offset);
        float v = 1-abs(n);
        v = v*v;
        v *= weight;
        weight = max(min(v*weightMultiplier,1),0);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    //float finalVal = -(pos.y + floorOffset) + noise * noiseWeight + (pos.y%params.x) * params.y;
    //float finalVal = (-pos.y + floorOffset) + (noise * noiseWeight) + (pos.y % 2);
    // Circle: float finalVal = radius - length(pos) +(noise * noiseWeight);
    //float finalVal = -(pos.y + floorOffset) + noise * noiseWeight + (pos.y%params.x) * params.y;
    float finalVal = radius - length(pos) +(noise * noiseWeight);

    if (pos.y < hardFloor) {
        finalVal += hardFloorWeight;
    }

    if (closeEdges) {
        float3 edgeOffset = abs(pos*2)-worldSize + spacing/2;
        float edgeWeight = saturate(sign(max(max(edgeOffset.x,edgeOffset.y),edgeOffset.z)));
        finalVal = finalVal * (1-edgeWeight) - 100 * edgeWeight;
        
    }
    

    int index = indexFromCoord(id.x,id.y,id.z);

    //float finalVal = snoise(pos);

    finalVal = Unity_InverseLerp_float4(-34, 16, finalVal);
    points[index] = float4(pos, finalVal);
    

}

