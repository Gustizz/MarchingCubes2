// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "NoiseShader.compute"
#include "Includes/NoiseShader.compute"
#include "Includes/PositionShader.compute"

StructuredBuffer<float3> offsets;
int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float floorOffset;
float weightMultiplier;
bool closeEdges;
float hardFloor;
float hardFloorWeight;
float4 params;
float radius;

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    if (id.x < numOfPointsPerAxis && id.y < numOfPointsPerAxis && id.z < numOfPointsPerAxis)
    {
        //Position
        // Calculate the position for this vertex
        float3 position = float3(
            (id.x / (float)(numOfPointsPerAxis - 1) * chunkSize) - (chunkSize * 0.5f) + centre.x,
            (id.y / (float)(numOfPointsPerAxis - 1)* chunkSize) - (chunkSize * 0.5f) + centre.y,
            (id.z / (float)(numOfPointsPerAxis - 1)* chunkSize) - (chunkSize * 0.5f) + centre.z);

        //Nabbed from https://github.com/SebLague/Marching-Cubes/blob/master/Assets/Scripts/Compute/NoiseDensity.compute for noise
        float offsetNoise = 0;

        float noise = 0;

        float frequency = noiseScale/100;
        float amplitude = 1;
        float weight = 1;
        for (int j =0; j < octaves; j ++) {
            float n = snoise((position+offsetNoise) * frequency + offsets[j] + offset);
            float v = 1-abs(n);
            v = v*v;
            v *= weight;
            weight = max(min(v*weightMultiplier,1),0);
            noise += v * amplitude;
            amplitude *= persistence;
            frequency *= lacunarity;
        }
    
        //float finalVal = -(pos.y + floorOffset) + noise * noiseWeight + (pos.y%params.x) * params.y;
        //float finalVal = (-pos.y + floorOffset) + (noise * noiseWeight) + (pos.y % 2);
        float finalVal = radius - length(position) +(noise * noiseWeight);

        if (position.y < hardFloor) {
            finalVal += hardFloorWeight;
        }



        
        // Store the position in the buffer
        points[id.x + numOfPointsPerAxis * (id.y + numOfPointsPerAxis * id.z)] = float4(position, finalVal);
        //points[id.z * numOfPointsPerAxis * numOfPointsPerAxis + id.y * numOfPointsPerAxis * id.x] = float4(position, finalVal);

    }
}
